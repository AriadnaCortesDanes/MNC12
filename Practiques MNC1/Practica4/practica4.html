
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>practica4</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-10-18"><meta name="DC.source" content="practica4.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">P4: Cort&eacute;s y Garc&iacute;a</a></li><li><a href="#2">Problema</a></li><li><a href="#3">Apartado (a) : Ecuaci&oacute;n F</a></li><li><a href="#4">Apartado (b) : Punto de impacto</a></li><li><a href="#5">Apartado (c) : Representaci&oacute;n gr&aacute;fica</a></li><li><a href="#6">Apartado (d) : Orden de convergencia</a></li><li><a href="#7">Apartado (e): &Aacute;ngulo variable</a></li><li><a href="#8">(e) (i) Coordenada de impacto e iteraciones en funci&oacute;n del &aacute;ngulo</a></li><li><a href="#9">(e) (ii)</a></li><li><a href="#10">(e) (iii)</a></li></ul></div><h2 id="1">P4: Cort&eacute;s y Garc&iacute;a</h2><pre class="codeinput">clear <span class="string">all</span>
format <span class="string">long</span>
</pre><h2 id="2">Problema</h2><pre class="codeinput">g = -9.81; <span class="comment">% m/s^2</span>

v0 = 37; <span class="comment">% m/s</span>
alpha0 = 67.5; <span class="comment">% &ordm;</span>

a = 0.15; <span class="comment">%m^-1</span>
b = 0.04; <span class="comment">% m^-1</span>
x0 = 0; y0 = 0; <span class="comment">% m</span>

y_hill = @(x) a.*x.^2.*exp(-b.*x);
</pre><h2 id="3">Apartado (a) : Ecuaci&oacute;n F</h2><p>La pelota describir&aacute; una par&aacute;bola, por lo que su trayectoria ser&aacute;: x = x0 + v0x*t y = y0 + v0y*t + 0.5*g*t^2</p><pre class="codeinput"><span class="comment">% Si aislamos t en funci&oacute;n de x en la primera ecuaci&oacute;n y lo substituimos en</span>
<span class="comment">% la segunda, tenemos:</span>
y_ball = @(x, v0, alpha0) y0+(x-x0).*tand(alpha0)+0.5*g*((x-x0)/(v0*cosd(alpha0))).^2;

<span class="comment">% Definimos F(x,v0,alpha0). La intersecci&oacute;n sucede cuando y_hill = y_ball. Por</span>
<span class="comment">% lo tanto, definiremos F como la diferencia entre ambas funciones</span>
<span class="comment">% F = y_ball - y_hill</span>
F = @(x, v0, alpha0) y0+(x-x0).*tand(alpha0)+0.5*g*((x-x0)/(v0*cosd(alpha0))).^2-a.*x.^2.*exp(-b.*x);

x = [0:1:200];

figure(1) <span class="comment">% Hacemos los gr&aacute;ficos de inter&eacute;s</span>
area(x, y_hill(x), <span class="string">'LineWidth'</span>,2,<span class="string">'FaceColor'</span>,[0.50 0.75 0.75])
hold <span class="string">on</span>
plot(x, y_ball(x, v0, alpha0), <span class="string">'LineWidth'</span>, 2)
plot(x, F(x, v0, alpha0), <span class="string">'LineWidth'</span>, 2, <span class="string">'LineStyle'</span>, <span class="string">'--'</span>, <span class="string">'Color'</span>, <span class="string">'b'</span>)
hold <span class="string">off</span>
grid <span class="string">on</span>;
title(<span class="string">'Mont&iacute;culo y_{hill}, par&aacute;bola y_{ball} e intersecci&oacute;n F(x, v_0, \alpha_0)'</span>)
ylim([0, 70]);
xlabel(<span class="string">'Posici&oacute;n x (m)'</span>, <span class="string">'fontsize'</span>,14)
ylabel(<span class="string">'Posici&oacute;n y (m)'</span>, <span class="string">'fontsize'</span>,14)

<span class="comment">% Tanto la trayectoria de la bola como F, llegan a valores negativos.</span>
<span class="comment">% Puesto que a partir de y = 0 la bola no puede caer m&aacute;s, no se muestran en</span>
<span class="comment">% la gr&aacute;fica los valores negativos.</span>
</pre><img vspace="5" hspace="5" src="practica4_01.png" alt=""> <h2 id="4">Apartado (b) : Punto de impacto</h2><p>El punto de impacto es el valor de x para el que F(x, v0, alpha0) = 0</p><pre class="codeinput">x1 = 75;
tol = 1e-12;
itmax = 50;
param = [v0, alpha0, a, b];

[xkvec, fkvec, it_last] = newton(x1, tol, itmax, param);

root = xkvec(end) <span class="comment">% Coordenada del impacto</span>

<span class="comment">% Implementaci&oacute;n funciones</span>

<span class="comment">% Funci&oacute;n F (F.m)</span>
<span class="comment">%   Entrada: valor de x, vector con par&aacute;metros incluidos en la definici&oacute;n</span>
<span class="comment">%   de la funci&oacute;n</span>
<span class="comment">%   Salida: valor de la funci&oacute;n evaluada en x dados los par&aacute;metros</span>
<span class="comment">% function [f] = F(x, param)</span>
<span class="comment">%     % definimos g como valor auxiliar</span>
<span class="comment">%     g = -9.81;</span>
<span class="comment">%</span>
<span class="comment">%     % Extraemos los valores de los par&aacute;metros</span>
<span class="comment">%     v0 = param(1);</span>
<span class="comment">%     alpha0 = param(2);</span>
<span class="comment">%     a = param(3);</span>
<span class="comment">%     b = param(4);</span>
<span class="comment">%</span>
<span class="comment">%     % Evaluamos la funci&oacute;n deseada</span>
<span class="comment">%     f = x.*tand(alpha0)+0.5*g*(x/(v0*cosd(alpha0))).^2-a.*x.^2.*exp(-b.*x);</span>
<span class="comment">% end</span>

<span class="comment">% Funci&oacute;n derivada (derivada.m)</span>
<span class="comment">%   Entrada: valor de x, vector con par&aacute;metros incluidos en la definici&oacute;n</span>
<span class="comment">%   de la funci&oacute;n</span>
<span class="comment">%   Salida: derivada de la funci&oacute;n evaluada en x</span>
<span class="comment">% function der = derivada(x0, param);</span>
<span class="comment">%     dx = 1e-6;</span>
<span class="comment">%     der = (F(x0+dx, param)-F(x0, param))/dx;</span>
<span class="comment">% end</span>

<span class="comment">% Funci&oacute;n newton (newton.m)</span>
<span class="comment">%   Entrada: valor inicial de x (x1), tolerancia permitida (tol), m&aacute;ximo de</span>
<span class="comment">%   iteraciones deseado (itmax), vector de par&aacute;metros auxiliares (param)</span>
<span class="comment">%   Salida: vector de xk obtenidas, funci&oacute;n evaluada en xk (fk) y valor de la</span>
<span class="comment">%   ultima iteraci&oacute;n (it)</span>
<span class="comment">% function [xk,fk,it] = newton(x1,tol,itmax, param)</span>
<span class="comment">%     it = 0;</span>
<span class="comment">%     xk = [x1];</span>
<span class="comment">%     fk = [F(x1, param)];</span>
<span class="comment">%     ek = 1;</span>
<span class="comment">%</span>
<span class="comment">%     while ek &gt; tol &amp;&amp; it &lt; itmax</span>
<span class="comment">%         x = xk(end) - F(xk(end), param)/derivada(xk(end), param);</span>
<span class="comment">%         ek = abs(x - xk(length(xk)));</span>
<span class="comment">%         xk = [xk x];</span>
<span class="comment">%         fk = [fk F(x, param)];</span>
<span class="comment">%         it = it + 1;</span>
<span class="comment">%     end</span>
<span class="comment">% end</span>
</pre><pre class="codeoutput">
root =

  76.953686828663578

</pre><h2 id="5">Apartado (c) : Representaci&oacute;n gr&aacute;fica</h2><pre class="codeinput">ekvec = abs(xkvec - root); <span class="comment">% error</span>

it = [1:1:it_last+1]; <span class="comment">% vector de iteraciones</span>

<span class="comment">% Gr&aacute;fica del error respecto a la iteraci&oacute;n</span>
figure(2)
plot(it, ekvec, <span class="string">'LineWidth'</span>, 2)
grid <span class="string">on</span>
title(<span class="string">'Representaci&oacute;n del error en cada iteraci&oacute;n'</span>)
xlabel(<span class="string">'Error \epsilon'</span>)
ylabel(<span class="string">'Iteraci&oacute;n'</span>)

<span class="comment">% Vemos que el error tiende a 0 en todo momento y, aunque de manera poco</span>
<span class="comment">% perceptible, se acerca cada vez m&aacute;s.</span>

<span class="comment">% Gr&aacute;fica del valor xk respecto a la iteraci&oacute;n</span>
figure(3)
plot(it, xkvec, <span class="string">'LineWidth'</span>, 2)
grid <span class="string">on</span>
title(<span class="string">'Representaci&oacute;n del valor de x en cada iteraci&oacute;n'</span>)
xlabel(<span class="string">'x'</span>)
ylabel(<span class="string">'Iteraci&oacute;n'</span>)

<span class="comment">% Vemos que el valor de xk se acerca m&aacute;s al valor de la ra&iacute;z de la funci&oacute;n</span>
<span class="comment">% a cada iteraci&oacute;n.</span>
</pre><img vspace="5" hspace="5" src="practica4_02.png" alt=""> <img vspace="5" hspace="5" src="practica4_03.png" alt=""> <h2 id="6">Apartado (d) : Orden de convergencia</h2><p>Primero calcularemos los vectores Xk e Yk donde: Xk = log(e_k) Yk = log(e_{k+1}) El primer y el &uacute;ltimo elemento de cada vector ser&aacute;n suprimidos porque pueden dar lugar a errores computacionales</p><pre class="codeinput">Xk = log10(ekvec(2:it_last-1));
Yk = log10(ekvec(3:it_last));

[r,p,d] = reg_lin(Xk,Yk);

p <span class="comment">% valor de p calculado con la regresi&oacute;n lineal</span>

<span class="comment">% obtenemos un orden de convergencia de p = 1.2789, por lo que si</span>
<span class="comment">% tuvieramos que dar un valor entero dir&iacute;amos que p = 2.</span>

<span class="comment">% Implementaci&oacute;n funciones</span>

<span class="comment">% Funci&oacute;n reg_lin (reg_lin.m)</span>
<span class="comment">%   Entrada: vectores x,y</span>
<span class="comment">%   Salida: coeficiente de regresi&oacute;n lineal (r), pendiente de la recta (a)</span>
<span class="comment">%   y ordenada en el origen (b)</span>
<span class="comment">% function [r,a,b]=reg_lin(x,y)</span>
<span class="comment">%     n=size(x ,2);</span>
<span class="comment">%</span>
<span class="comment">%     ax=sum(x)/n; ay=sum(y)/n;</span>
<span class="comment">%</span>
<span class="comment">%     ax2=sum(x.^2)/n; ay2=sum(y.^2)/n; axy=sum(x.*y)/n;</span>
<span class="comment">%</span>
<span class="comment">%     a=(axy-ax*ay)/(ax2-ax^2);</span>
<span class="comment">%     c=(axy-ax*ay)/(ay2-ay^2);</span>
<span class="comment">%     r=sqrt(a*c);</span>
<span class="comment">%     b=ay-a*ax;</span>
<span class="comment">%     d=ax-c*ay;</span>
<span class="comment">% end</span>
</pre><pre class="codeoutput">
p =

   1.278994600276342

</pre><h2 id="7">Apartado (e): &Aacute;ngulo variable</h2><h2 id="8">(e) (i) Coordenada de impacto e iteraciones en funci&oacute;n del &aacute;ngulo</h2><p>Declaramos par&aacute;metros necesarios</p><pre class="codeinput">x1 = 1;
x_imp =[];
it_imp = [];


<span class="keyword">for</span> angle = 5:1:80
    <span class="comment">% Creamos vector de par&aacute;metros</span>
    param = [v0, angle, a, b];

    <span class="comment">% Buscamos la ra&iacute;z para cada &aacute;ngulo</span>
    [xkvec, fkvec, it_last] = newton(x1, tol, itmax, param);

    <span class="comment">% Actualizamos los vectores y par&aacute;metros necesarios</span>
    it_imp = [it_imp it_last];
    x_imp = [x_imp xkvec(end)];
    x1 = abs(x_imp(end));
<span class="keyword">end</span>

alpha = [5:1:80]; <span class="comment">% creado para hacer la gr&aacute;fica</span>

<span class="comment">% Hacemos los gr&aacute;ficos necesarios</span>
figure(4)
plot(alpha,x_imp, <span class="string">'o'</span>, <span class="string">'LineWidth'</span>,2)
hold <span class="string">on</span>
plot(alpha, it_imp, <span class="string">'LineWidth'</span>, 2)
hold <span class="string">off</span>
axis([5 80 0 100])
grid <span class="string">on</span>
title(<span class="string">'x_{imp} y n&uacute;mero de iteraciones necesario seg&uacute;n \alpha_0'</span>)
xlabel(<span class="string">'\alpha_0 (&ordm;)'</span>, <span class="string">'fontsize'</span>,14)
legend(<span class="string">'x_{imp} (m)'</span>,<span class="string">'# iteraciones'</span>, <span class="string">'Location'</span>, <span class="string">'northwest'</span>)

<span class="comment">% Funci&oacute;n Newton implementada anteriormente.</span>
</pre><img vspace="5" hspace="5" src="practica4_04.png" alt=""> <h2 id="9">(e) (ii)</h2><p>Encontramos el valor de x que da altura del monticulo 50 (altura maxima)</p><pre class="codeinput">g_hill = @(x) a*x.^2.*exp(-b.*x) - 50;
x1 = 40;
[xk,fk,it] = minewton(x1,tol,itmax,g_hill);
x_hmax = xk(end);

<span class="comment">% Calculamos el &aacute;ngulo m&iacute;nimo</span>
x1 = 1;
alpha = 5;

<span class="comment">% Calculamos los valores de x_imp y h_max alcanzada para alpha = 5.</span>
param = [v0, alpha, a, b];
[xkvec, fkvec, it_last] = newton(x1, tol, itmax, param);

<span class="comment">% Saldremos del bucle cuando x_imp sea mayor o igual que la coordenada que</span>
<span class="comment">% da la altura m&aacute;xima del mont&iacute;culo, y la bola haya superado la altura del</span>
<span class="comment">% mismo</span>
<span class="keyword">while</span> xkvec(end) &lt; x_hmax
    <span class="comment">% Recalculamos los par&aacute;metros que necesitamos para alphas crecientes</span>
    alpha = alpha +0.1;
    param = [v0, alpha, a, b];
    [xkvec, fkvec, it_last] = newton(x1, tol, itmax, param);

    <span class="comment">% Tomamos los datos</span>
    x1 = xkvec(end);
<span class="keyword">end</span>

alpha_min = alpha
</pre><pre class="codeoutput">
alpha_min =

  61.700000000000607

</pre><h2 id="10">(e) (iii)</h2><p>Vemos que cuando \alpha = \alpha_{min} la trayectoria de la bola llega a ser tangente al mont&iacute;culo (aunque no llega a haber una intersecci&oacute;n). Al aplicar el m&eacute;todo de Newton en esta situaci&oacute;n, el programa podria llegar a entender (seg&uacute;n la tolerancia que se aplique) que hay dos ra&iacute;zes en posiciones muy cercanas. Se trata de un problema mal condicionado, por lo que las soluciones podr&iacute;an no ser fiables. Si miramos el gr&aacute;fico obtenido en el apartado (e)(i), vemos que este &aacute;ngulo est&aacute; muy cerca de una discontinuidad. Tambi&eacute;n vemos que se da un aumento del n&uacute;mero de iteraciones necesario para llegar a la ra&iacute;z, debido al mal condicionamiento del problema para este &aacute;ngulo.</p><pre class="codeinput">x = [0:1:200];

figure(5)
area(x, y_hill(x), <span class="string">'LineWidth'</span>,2,<span class="string">'FaceColor'</span>,[0.50 0.75 0.75])
hold <span class="string">on</span>
plot(x, y_ball(x, v0, alpha_min), <span class="string">'LineWidth'</span>, 2)
plot(x, F(x, v0, alpha_min), <span class="string">'LineWidth'</span>, 2, <span class="string">'LineStyle'</span>, <span class="string">'--'</span>, <span class="string">'Color'</span>, <span class="string">'b'</span>)
hold <span class="string">off</span>
grid <span class="string">on</span>;
title(<span class="string">'Mont&iacute;culo y_{hill}, par&aacute;bola y_{ball} e intersecci&oacute;n F(x, v_0, \alpha_0)'</span>)
ylim([0, 70]);
xlabel(<span class="string">'Posici&oacute;n x (m)'</span>, <span class="string">'fontsize'</span>,14)
ylabel(<span class="string">'Posici&oacute;n y (m)'</span>, <span class="string">'fontsize'</span>,14)

<span class="comment">% Implementaci&oacute;n de funciones</span>

<span class="comment">% Funci&oacute;n derivative (derivative.m)</span>
<span class="comment">%   Entrada: funci&oacute;n a evaluar (f), valor de x para evaluar (x0)</span>
<span class="comment">%   Salida: Evaluaci&oacute;n de f'(x) en x0</span>
<span class="comment">% function der = derivative(f, x0)</span>
<span class="comment">%     dx = 1e-6;</span>
<span class="comment">%     der = (f(x0+dx)-f(x0))/dx;</span>
<span class="comment">% end</span>

<span class="comment">% Funci&oacute;n minewton (minewton.m)</span>
<span class="comment">%   Entrada: valor inicial de x (x1), tolerancia permitida (tol), m&aacute;ximo de</span>
<span class="comment">%   iteraciones deseado (itmax), funci&oacute;n de la que se pretende encontrar la</span>
<span class="comment">%   raiz (fun)</span>
<span class="comment">%   Salida: vector de xk obtenidas, vector de funci&oacute;n evaluada en xk (fk)</span>
<span class="comment">%   y valor de la ultima iteraci&oacute;n (it)</span>
<span class="comment">% function [xk,fk,it] = minewton(x1,tol,itmax,fun)</span>
<span class="comment">%     it = 0;</span>
<span class="comment">%     xk = [x1];</span>
<span class="comment">%     fk = [fun(x1)];</span>
<span class="comment">%     ek = 1;</span>
<span class="comment">%</span>
<span class="comment">%     while ek &gt; tol &amp;&amp; it &lt; itmax</span>
<span class="comment">%         x = xk(end) - fun(xk(end))/derivative(fun,xk(end));</span>
<span class="comment">%         ek = abs(x - xk(end));</span>
<span class="comment">%         xk = [xk x];</span>
<span class="comment">%         fk = [fk fun(x)];</span>
<span class="comment">%         it = it + 1;</span>
<span class="comment">%     end</span>
<span class="comment">% end</span>
</pre><img vspace="5" hspace="5" src="practica4_05.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% P4: Cortés y García

clear all
format long
%% Problema
g = -9.81; % m/s^2

v0 = 37; % m/s
alpha0 = 67.5; % º

a = 0.15; %m^-1
b = 0.04; % m^-1
x0 = 0; y0 = 0; % m

y_hill = @(x) a.*x.^2.*exp(-b.*x);

%% Apartado (a) : Ecuación F
% La pelota describirá una parábola, por lo que su trayectoria será:
% x = x0 + v0x*t
% y = y0 + v0y*t + 0.5*g*t^2

% Si aislamos t en función de x en la primera ecuación y lo substituimos en
% la segunda, tenemos:
y_ball = @(x, v0, alpha0) y0+(x-x0).*tand(alpha0)+0.5*g*((x-x0)/(v0*cosd(alpha0))).^2;

% Definimos F(x,v0,alpha0). La intersección sucede cuando y_hill = y_ball. Por
% lo tanto, definiremos F como la diferencia entre ambas funciones
% F = y_ball - y_hill
F = @(x, v0, alpha0) y0+(x-x0).*tand(alpha0)+0.5*g*((x-x0)/(v0*cosd(alpha0))).^2-a.*x.^2.*exp(-b.*x);

x = [0:1:200];

figure(1) % Hacemos los gráficos de interés
area(x, y_hill(x), 'LineWidth',2,'FaceColor',[0.50 0.75 0.75])
hold on
plot(x, y_ball(x, v0, alpha0), 'LineWidth', 2)
plot(x, F(x, v0, alpha0), 'LineWidth', 2, 'LineStyle', 'REPLACE_WITH_DASH_DASH', 'Color', 'b')
hold off
grid on;
title('Montículo y_{hill}, parábola y_{ball} e intersección F(x, v_0, \alpha_0)')
ylim([0, 70]);
xlabel('Posición x (m)', 'fontsize',14)
ylabel('Posición y (m)', 'fontsize',14)

% Tanto la trayectoria de la bola como F, llegan a valores negativos.
% Puesto que a partir de y = 0 la bola no puede caer más, no se muestran en
% la gráfica los valores negativos.

%% Apartado (b) : Punto de impacto
% El punto de impacto es el valor de x para el que F(x, v0, alpha0) = 0
x1 = 75;
tol = 1e-12;
itmax = 50;
param = [v0, alpha0, a, b];

[xkvec, fkvec, it_last] = newton(x1, tol, itmax, param);

root = xkvec(end) % Coordenada del impacto

% Implementación funciones

% Función F (F.m)
%   Entrada: valor de x, vector con parámetros incluidos en la definición
%   de la función
%   Salida: valor de la función evaluada en x dados los parámetros
% function [f] = F(x, param)
%     % definimos g como valor auxiliar  
%     g = -9.81;
%     
%     % Extraemos los valores de los parámetros
%     v0 = param(1);
%     alpha0 = param(2);
%     a = param(3);
%     b = param(4);
%     
%     % Evaluamos la función deseada
%     f = x.*tand(alpha0)+0.5*g*(x/(v0*cosd(alpha0))).^2-a.*x.^2.*exp(-b.*x);
% end

% Función derivada (derivada.m)
%   Entrada: valor de x, vector con parámetros incluidos en la definición
%   de la función
%   Salida: derivada de la función evaluada en x
% function der = derivada(x0, param);
%     dx = 1e-6;
%     der = (F(x0+dx, param)-F(x0, param))/dx;
% end

% Función newton (newton.m)
%   Entrada: valor inicial de x (x1), tolerancia permitida (tol), máximo de
%   iteraciones deseado (itmax), vector de parámetros auxiliares (param)
%   Salida: vector de xk obtenidas, función evaluada en xk (fk) y valor de la
%   ultima iteración (it)
% function [xk,fk,it] = newton(x1,tol,itmax, param)
%     it = 0;
%     xk = [x1];
%     fk = [F(x1, param)];
%     ek = 1;
%     
%     while ek > tol && it < itmax
%         x = xk(end) - F(xk(end), param)/derivada(xk(end), param);
%         ek = abs(x - xk(length(xk)));
%         xk = [xk x];
%         fk = [fk F(x, param)];
%         it = it + 1;
%     end
% end
%% Apartado (c) : Representación gráfica
ekvec = abs(xkvec - root); % error

it = [1:1:it_last+1]; % vector de iteraciones

% Gráfica del error respecto a la iteración
figure(2)
plot(it, ekvec, 'LineWidth', 2)
grid on
title('Representación del error en cada iteración')
xlabel('Error \epsilon')
ylabel('Iteración')

% Vemos que el error tiende a 0 en todo momento y, aunque de manera poco
% perceptible, se acerca cada vez más.

% Gráfica del valor xk respecto a la iteración
figure(3)
plot(it, xkvec, 'LineWidth', 2)
grid on
title('Representación del valor de x en cada iteración')
xlabel('x')
ylabel('Iteración')

% Vemos que el valor de xk se acerca más al valor de la raíz de la función
% a cada iteración.

%% Apartado (d) : Orden de convergencia
% Primero calcularemos los vectores Xk e Yk donde:
% Xk = log(e_k)
% Yk = log(e_{k+1})
% El primer y el último elemento de cada vector serán suprimidos porque 
% pueden dar lugar a errores computacionales
Xk = log10(ekvec(2:it_last-1));
Yk = log10(ekvec(3:it_last));

[r,p,d] = reg_lin(Xk,Yk);

p % valor de p calculado con la regresión lineal

% obtenemos un orden de convergencia de p = 1.2789, por lo que si
% tuvieramos que dar un valor entero diríamos que p = 2.

% Implementación funciones

% Función reg_lin (reg_lin.m)
%   Entrada: vectores x,y
%   Salida: coeficiente de regresión lineal (r), pendiente de la recta (a)
%   y ordenada en el origen (b)
% function [r,a,b]=reg_lin(x,y)
%     n=size(x ,2);
% 
%     ax=sum(x)/n; ay=sum(y)/n; 
% 
%     ax2=sum(x.^2)/n; ay2=sum(y.^2)/n; axy=sum(x.*y)/n;
% 
%     a=(axy-ax*ay)/(ax2-ax^2);
%     c=(axy-ax*ay)/(ay2-ay^2);
%     r=sqrt(a*c);
%     b=ay-a*ax;
%     d=ax-c*ay;
% end

%% Apartado (e): Ángulo variable
%% (e) (i) Coordenada de impacto e iteraciones en función del ángulo
% Declaramos parámetros necesarios
x1 = 1;
x_imp =[];
it_imp = [];


for angle = 5:1:80
    % Creamos vector de parámetros
    param = [v0, angle, a, b];
    
    % Buscamos la raíz para cada ángulo
    [xkvec, fkvec, it_last] = newton(x1, tol, itmax, param);
    
    % Actualizamos los vectores y parámetros necesarios
    it_imp = [it_imp it_last];
    x_imp = [x_imp xkvec(end)];
    x1 = abs(x_imp(end));
end

alpha = [5:1:80]; % creado para hacer la gráfica

% Hacemos los gráficos necesarios
figure(4)
plot(alpha,x_imp, 'o', 'LineWidth',2)
hold on
plot(alpha, it_imp, 'LineWidth', 2)
hold off
axis([5 80 0 100])
grid on
title('x_{imp} y número de iteraciones necesario según \alpha_0')
xlabel('\alpha_0 (º)', 'fontsize',14)
legend('x_{imp} (m)','# iteraciones', 'Location', 'northwest')

% Función Newton implementada anteriormente.

%% (e) (ii)
% Encontramos el valor de x que da altura del monticulo 50 (altura maxima)
g_hill = @(x) a*x.^2.*exp(-b.*x) - 50;
x1 = 40;
[xk,fk,it] = minewton(x1,tol,itmax,g_hill);
x_hmax = xk(end);

% Calculamos el ángulo mínimo
x1 = 1;
alpha = 5;

% Calculamos los valores de x_imp y h_max alcanzada para alpha = 5.
param = [v0, alpha, a, b];
[xkvec, fkvec, it_last] = newton(x1, tol, itmax, param);

% Saldremos del bucle cuando x_imp sea mayor o igual que la coordenada que
% da la altura máxima del montículo, y la bola haya superado la altura del
% mismo
while xkvec(end) < x_hmax
    % Recalculamos los parámetros que necesitamos para alphas crecientes
    alpha = alpha +0.1;
    param = [v0, alpha, a, b];
    [xkvec, fkvec, it_last] = newton(x1, tol, itmax, param);
    
    % Tomamos los datos
    x1 = xkvec(end);
end

alpha_min = alpha

%% (e) (iii)
% Vemos que cuando \alpha = \alpha_{min} la trayectoria de la bola llega a ser tangente al
% montículo (aunque no llega a haber una intersección). Al aplicar el
% método de Newton en esta situación, el programa podria llegar a entender
% (según la tolerancia que se aplique) que hay dos raízes en posiciones muy
% cercanas. Se trata de un problema mal condicionado, por lo que las
% soluciones podrían no ser fiables.
% Si miramos el gráfico obtenido en el apartado (e)(i), vemos que este
% ángulo está muy cerca de una discontinuidad. También vemos que se da un
% aumento del número de iteraciones necesario para llegar a la raíz, debido
% al mal condicionamiento del problema para este ángulo.

x = [0:1:200];

figure(5)
area(x, y_hill(x), 'LineWidth',2,'FaceColor',[0.50 0.75 0.75])
hold on
plot(x, y_ball(x, v0, alpha_min), 'LineWidth', 2)
plot(x, F(x, v0, alpha_min), 'LineWidth', 2, 'LineStyle', 'REPLACE_WITH_DASH_DASH', 'Color', 'b')
hold off
grid on;
title('Montículo y_{hill}, parábola y_{ball} e intersección F(x, v_0, \alpha_0)')
ylim([0, 70]);
xlabel('Posición x (m)', 'fontsize',14)
ylabel('Posición y (m)', 'fontsize',14)

% Implementación de funciones

% Función derivative (derivative.m)
%   Entrada: función a evaluar (f), valor de x para evaluar (x0)
%   Salida: Evaluación de f'(x) en x0
% function der = derivative(f, x0)
%     dx = 1e-6;
%     der = (f(x0+dx)-f(x0))/dx;
% end

% Función minewton (minewton.m)
%   Entrada: valor inicial de x (x1), tolerancia permitida (tol), máximo de
%   iteraciones deseado (itmax), función de la que se pretende encontrar la
%   raiz (fun)
%   Salida: vector de xk obtenidas, vector de función evaluada en xk (fk) 
%   y valor de la ultima iteración (it)
% function [xk,fk,it] = minewton(x1,tol,itmax,fun)
%     it = 0;
%     xk = [x1];
%     fk = [fun(x1)];
%     ek = 1;
%     
%     while ek > tol && it < itmax
%         x = xk(end) - fun(xk(end))/derivative(fun,xk(end));
%         ek = abs(x - xk(end));
%         xk = [xk x];
%         fk = [fk fun(x)];
%         it = it + 1;
%     end
% end
##### SOURCE END #####
--></body></html>